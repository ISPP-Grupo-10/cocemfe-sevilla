# Metodología de trabajo
****
| NOMBRE DEL PROYECTO | CLIENTE  | EQUIPO DE TRABAJO | FECHA DE ELABORACIÓN | FASE DEL PROYECTO  |
|---------------------|----------|-------------------|----------------------|--------------------|
| Cocemfe-Web         | COCEMFE  | Grupo 10          | 16/02/2024           | Devising a project |


| MIEMBROS DEL EQUIPO DE TRABAJO | MIEMBROS DEL EQUIPO DE TRABAJO |
|--------------------------------|--------------------------------|
| Ignacio Arroyo Mantero         | Eloy Jiménez Medina            |
| Tadeo Cabrera Gómez            | Daniel Cortés Fonseca          |
| Andrés Jesús Somoza Sierra     | Fernando Baquero Fernández     |
| Pablo Pino Mateo               | Guillermo Gómez Romero         |
| Antonio Maqueda Acal           | Jesús Solís Ortega             |
| Gonzalo Ribas Luna             | Jaime García García            |
| Antonio Peláez Moreno          | Lucas Antoñanzas del Villar    |
| Álvaro Vázquez Conejo          | Raúl Hernán Mérida Bascón      |
| Ignacio González González      |                                |

****

## 1. Introducción

El propósito de este documento es doble: en primer lugar, proporcionar una guía detallada sobre las técnicas y procesos para la gestión de la configuración en el proyecto ejecutado para COCEMFE; en segundo lugar, abordar procedimientos adicionales de evaluación y mediciones destinados a analizar el desempeño del equipo de desarrollo. 
<br/>Este conjunto integral de prácticas se alinea con los principios y valores fundamentales de Scrum, ofreciendo una base sólida para el control efectivo del entorno de desarrollo. A continuación, se presenta una breve descripción de Scrum y sus principios como contexto esencial para comprender la aplicación de estas prácticas en el marco de nuestro proyecto.

## 2. Metodología de Trabajo

Las metodologías ágiles se centran en la flexibilidad y la entrega iterativa de productos de alta calidad. Sus principios fundamentales se alinean estrechamente con la filosofía de la mejora continua y la adaptabilidad. Dada la naturaleza de este proyecto, con un alcance no fijo, se ha decidido seguir dicha metodología durante el desarrollo de este, inspirándose en Scrum, aunque adaptándolo a las necesidades específicas del proyecto. Algunos de los principios ágiles clave incluyen la transparencia, la inspección y la adaptación, promoviendo la colaboración y la comunicación efectiva entre los miembros del equipo. <br/> Al combinar estas prácticas con los principios de Scrum, buscamos optimizar el rendimiento del equipo y garantizar una gestión eficaz de la configuración, contribuyendo así al éxito del proyecto ejecutado para COCEMFE.

### 2.1 Roles y Responsabilidades

En esta sección del documento se abordan los roles clave en el trabajo Scrum, delineando las responsabilidades asociadas con cada uno. La claridad en los roles y responsabilidades contribuye a un desarrollo eficiente y a la colaboración efectiva dentro del equipo.

#### 2.1.1 Stakeholders

Los stakeholders son los profesores de la asignatura y la ONG. Su función dentro del proyecto es garantizar que el equipo de desarrollo cumpla las necesidades y expectativas del cliente, así como tomar decisiones sobre la entrega de incremento de producto.

#### 2.1.2 Equipo de Desarrollo

El equipo de desarrollo está compuesto por los 17 miembros del grupo 10 de ISPP. Sus responsabilidades incluyen:
- Participar en la planificación y ejecución de los Sprints.
- Colaborar estrechamente para alcanzar los objetivos del sprint.
- Ser proactivo en la resolución de problemas y la mejora continua. 

Durante el desarrollo del proyecto, estos se dividirán en 4 subgrupos, con un representante en cada uno, para agilizar el trabajo y reducir las comunicaciones entre miembros a solo las necesarias basándonos en la ley de Brooks sobre la complejidad del Software.

#### 2.1.3 Representantes de Subgrupos

En el proyecto, como se ha mencionado anteriormente, contamos con 4 subgrupos de trabajo, cada uno tendrá un representante. Sus responsabilidades abarcan:
- Eliminar obstáculos que afecten al equipo.
- Representar a su subgrupo en las reuniones de Sprint Planning.
- Garantizar el cumplimiento de las buenas prácticas.
- Facilitar reuniones.

### 2.2 Product Backlog

El Product Backlog es una lista dinámica de todas las funcionalidades, mejoras y cambios deseados en el producto, y la prioridad de estas. La creación del Product Backlog es una tarea del equipo del trabajo.

### 2.3 Ciclo de Desarrollo

En Scrum, el ciclo de desarrollo se organiza en iteraciones llamadas "sprints" y el trabajo se repartirá por semanas desde el inicio del proyecto. Esta sección detalla la duración y la estructura de estos sprints, proporcionando una visión general del marco temporal y la dinámica de trabajo. Adicionalmente a los sprints el proyecto consta de otras actividades no enmarcadas en los sprints que se detallarán a continuación.

#### 2.3.1 Duración y Estructura del Proyecto
 
**Duración del Proyecto**
- El proyecto durará en total 15 semanas de trabajo, con 2 semanas de permiso para el equipo (Semana Santa y feria).
- Las 4 primeras semanas no se incluyen en este documento, ya que corresponden al inicio y planificación del proyecto.

**Duración de los Sprints**
- Habrá 3 Sprints a lo largo del proyecto, distribuidos de la siguiente manera:
  - Sprint 1 (#S1): Semanas 5 y 6.
  - Sprint 2 (#S2): Semanas 8 y 9.
  - Sprint 3 (#S3): Semanas 10 y 11.

**Planificación del Sprint**
- Se seleccionan elementos del Product Backlog para abordar durante el sprint.
- Colaboración con los responsables de la organización para definir, aprobar e incrementar elementos.
- Al menos una reunión con el cliente antes de cada Sprint.

**Ejecución del Sprint**
- Reunión en cada Sprint para asignar tareas por subgrupos.
- Reuniones semanales de seguimiento en cada subgrupo, no superando los 20 minutos.

**Revisión de Sprint**
- Evento de revisión tras cada Sprint para presentar el trabajo completado a los stakeholders y obtener feedback.

**Retrospectiva de Sprint**
- Reflexión sobre el sprint y formulación de mejoras para el próximo, realizada antes del siguiente sprint (si lo hay).

**Otras Actividades**
- **Sesión de retrospectiva de los grupos**: La semana 7 se dedicará
a hacer una retrospectiva general del trabajo realizado hasta la
fecha y se propondrán medidas correctivas en caso de que sea
necesario. Esta actividad es importante ya que se encuentra en
la mitad del desarrollo y sirve para garantizar el alcance, calidad
del proyecto y el compromiso de los involucrados con los
objetivos.
- **Preparación del lanzamiento del proyecto**: Incluye todas las
actividades relativas al lanzamiento, puesta a punto, guías de
usuario para el mantenimiento y gestión de la solución software
definitiva, así como la publicidad, análisis de competidores,
planificación técnica y financiera, etc. En caso de que se
considere oportuno. Tendrá lugar durante las semanas 12 y 13.
- **Lanzamiento y retrospectiva final**: Se hará una evaluación final
y revisión del trabajo realizado y se lanzará la versión final en
App Engine, así como se realizará una presentación en un
evento publico mostrando los resultados obtenidos. Esta última
fase ocupará las semanas 14 y 15.

## 3. Gestión de la Configuración

### 3.1 Estándares de Código
La aplicación de estándares de código tiene como objetivo inculcar en el proyecto prácticas de programación que conduzcan a un código seguro, comprobable y mantenible. El equipo ha identificado los siguientes estándares de código2:

- No se entregará código muerto o deprecado.
- Se utilizará el idioma inglés para el desarrollo del código.
- Se empleará el formato `snake_case` para Python.
- Los métodos se denominarán mediante verbos en imperativo.
- Las variables serán sustantivos que proporcionen significado al código.
- El nombre de las clases deberá estar capitalizado.
- Las constantes se escribirán siempre en mayúsculas y utilizando el separador "_".
- Todo fragmento de código deberá respetar la tabulación.
- Se comentarán debidamente los métodos complejos para facilitar la revisión por parte de personal ajeno al desarrollo.
- Se evitará el uso de los "magic numbers", es decir, la utilización directa de atributos de tipo entero que no hayan sido declarados como variables.

### 3.2 Políticas de Mensajes de Código

Los commits representan cambios en el código fuente y la adherencia a una estructura adecuada es esencial para facilitar la comprensión de las modificaciones realizadas en el sistema. A continuación, se detallan las pautas para los mensajes de commits:

- Se escribirán en español.
- Se separará el título del cuerpo con una línea en blanco.
- Se limitará el título a 50 caracteres cuando sea posible.
- Se capitalizará el título.
- No se colocará un punto final al título.
- Se usará el imperativo en el título.
- El resumen se limitará a 72 caracteres, si es necesario.
- Se distinguirán los siguientes tipos de commits: `Feat`, `fix`, `docs`, `style`, `refactor`, `test` y `conf`.
- Para garantizar la uniformidad, se empleará la plantilla que incorpora estas políticas.
- Los merge/pull request no se considerarán commits según estas políticas de código.
- No se realizarán commits o pull requests que no estén destinados a resolver problemas o gestionar la entrega o defensa (milestones) en las 24 horas previas a la defensa o entrega3.


### 3.3 Estructura del Repositorio

El repositorio constará de la siguiente estructura:
- Una carpeta para los documentos.
- Una carpeta para el testing.
- Una carpeta para los recursos audiovisuales.
- Una carpeta para la aplicación web con dentro:
  - Una carpeta por subsistema.
  - Archivos de configuración.
  
### 3.4 Gestión de Issues

Para todas las issues se especificarán la etiqueta y el milestone. Las posibles etiquetas que se usarán en este proyecto son:
- feature, configuration, documentation, style, refactor, testing, bug 

Para nombrar una issue, primero se pondrá la etiqueta correspondiente entre corchetes. Por ejemplo, "[Feature] Añadir inicio de sesión" o "[Testing] Mejorar cobertura de las pruebas de la clase Usuario"<br/>
En el caso de los milestones estos se añadirán tras la creación de la issue y se corresponden con la fase del proyecto en la que se crearon.
<br/>En el caso de las issues con etiqueta de feature estás tendrán vinculada una rama feature, para que así automatizar la gestión de estado de estas. Si se crea una issue que no requiere una nueva rama, por ejemplo, para modificar un fichero directamente en develop, la issue se cambiará de estado y cerrará manualmente. El nombre de esta expresará de manera concisa y breve la tarea a realizar.

### 3.5 Estrategias de Ramificación

Durante el desarrollo del proyecto se implementará un sistema de ramas para mantener la coherencia y trazabilidad dentro del proyecto. La estructura de las ramas será la siguiente:

- **Rama `master`**: Contendrá las versiones estables del proyecto listas para producción.
- **Rama `develop`**: Contendrá las versiones de desarrollo con los últimos cambios realizados.
- **Rama de `feature`**: Se creará a partir de la rama `develop`, una por cada funcionalidad a implementar. Al completar el trabajo en una rama `feature`, sus contenidos se combinarán con la rama `develop`. La nomenclatura seguirá el patrón "feature/X-Y", donde al id de la issue e Y es un título identificativo de la funcionalidad modificada en esa rama.

Al mergear una rama `feature` con la rama `develop`, se realizará un pull de `develop` a dicha rama previamente. Se resolverán los conflictos localmente, y para garantizar su correcto funcionamiento, se solicitará revisión a otro miembro del equipo mediante una pull request. Este miembro llevará a cabo pruebas informales y verificará que los cambios realizados funcionan correctamente sin causar errores en el resto del sistema.

Al mergear la rama `develop` con la rama `main`, se creará una pull request que deberá ser aprobada por dos miembros del equipo. Estos verificarán que todo funcione correctamente. El repositorio de GitHub está configurado para impedir el mergeo hasta que se cumplan estas condiciones.


### 3.6 Estrategia de Versionado

Con el objetivo de mejorar el control del versionado, se ha decidido seguir un estándar para la publicación de nuevas versiones del proyecto. El versionado será de la forma X.Y.Z, donde cada letra tendrá un número asociado según la versión.

Para cada commit que arregle un error del código base, mejore un comportamiento incorrecto del sistema pero que no añada nueva funcionalidad, el número asignado a Z en el versionado aumentará en uno su valor.

Si, por el contrario, hay un commit que incluya nueva funcionalidad o cambios mayores, la letra que aumentará en uno en el versionado es la X.

Por ejemplo, si la aplicación ya está completada (1.0.0) y arreglamos un bug, la nueva versión será 1.0.1. En el caso en el que corrijamos una nueva funcionalidad (otro requisito, por ejemplo) y a la vez se arregle otro bug, el nuevo versionado sería 1.1.2.




